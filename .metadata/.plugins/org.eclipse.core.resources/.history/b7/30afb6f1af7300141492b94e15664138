package groupa.deadlywheels.carcontrol;

import groupa.deadlywheels.core.CarDroiDuinoCore;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.Enumeration;

import org.apache.http.conn.util.InetAddressUtils;

import net.learn2develop.socketserver.MainActivity.ServerThread;

import android.os.Handler;
import android.util.Log;

public class DatagramSocketArduinoWorker implements Runnable {

	/**
	 * Core System - Prov Queues for Data Exchange between System Threads
	 */
	private CarDroiDuinoCore systemCore;

	/**
	 * Socket for connection via UPD with Server and receipt of Frames
	 */
	private DatagramSocket datagramSocket;

	/**
	 * Looping Control of Thread
	 */
	private boolean isOn = false;

	static String SERVER_IP = "http://192.168.100.105";
	static final int SERVER_PORT = 10002;

	Handler handler = new Handler();
	ServerSocket serverSocket;

	public DatagramSocketArduinoWorker(CarDroiDuinoCore systemCore,
			int clientPort) throws SocketException {
		// ---get the IP address of itself---
		SERVER_IP = getLocalIpv4Address();

		// ---start the server---
		Thread serverThread = new Thread(new ServerThread());
		serverThread.start();
	}

	// ---get the local IPv4 address---
	public String getLocalIpv4Address() {
		try {
			for (Enumeration<NetworkInterface> networkInterfaceEnum = NetworkInterface
					.getNetworkInterfaces(); networkInterfaceEnum
					.hasMoreElements();) {
				NetworkInterface networkInterface = networkInterfaceEnum
						.nextElement();
				for (Enumeration<InetAddress> ipAddressEnum = networkInterface
						.getInetAddresses(); ipAddressEnum.hasMoreElements();) {
					InetAddress inetAddress = (InetAddress) ipAddressEnum
							.nextElement();
					// ---check that it is not a loopback address and
					// it is IPv4---
					if (!inetAddress.isLoopbackAddress()
							&& InetAddressUtils.isIPv4Address(inetAddress
									.getHostAddress())) {
						return inetAddress.getHostAddress();
					}
				}
			}
		} catch (SocketException ex) {
			Log.e("IPAddress", ex.toString());
		}
		return null;
	}

	@Override
	public void run() {
		try {
			if (SERVER_IP != null) {
				handler.post(new Runnable() {
					@Override
					public void run() {
						System.out.println("error");
					}
				});

				// ---create an instance of the server socket---
				serverSocket = new ServerSocket(SERVER_PORT);

				while (true) {
					// ---wait for incoming clients---
					Socket client = serverSocket.accept();

					// ---the above code is a blocking call;
					// i.e. it will block until a client connects---

					// ---client has connected---
					handler.post(new Runnable() {
						@Override
						public void run() {
							System.out.println("error");
						}
					});

					try {
						// ---get an InputStream object to read from the
						// socket---
						BufferedReader br = new BufferedReader(
								new InputStreamReader(client.getInputStream()));

						OutputStream outputStream = client.getOutputStream();

						// ---read all incoming data terminated with a \n
						// char---
						String line = null;
						while ((line = br.readLine()) != null) {
							final String strReceived = line;

							// ---send whatever you received back to the
							// client---
							String s = line + "\n";
							outputStream.write(s.getBytes());

							this.systemCore.addDataToSensorQueue(s.getBytes());

							handler.post(new Runnable() {
								@Override
								public void run() {
									System.out.println("error");
								}
							});
						}

						// ---client has disconnected from the server---
						handler.post(new Runnable() {
							@Override
							public void run() {
								System.out.println("error");
							}
						});

					} catch (Exception e) {
						final String error = e.getLocalizedMessage();
						handler.post(new Runnable() {
							@Override
							public void run() {
								System.out.println("error" + error);
							}
						});
					}
				}
			} else {
				handler.post(new Runnable() {
					@Override
					public void run() {
						System.out.println("error");
					}
				});
			}
		} catch (Exception e) {
			final String error = e.getLocalizedMessage();
			handler.post(new Runnable() {
				@Override
				public void run() {
					System.out.println("error" + error);
				}
			});
		}
	}

	/**
	 * Thread the ends of communication
	 */
	public void turnOff() {
		this.isOn = false;
		try {
			this.datagramSocket.disconnect();
			this.datagramSocket.close();
		} catch (Exception ex) {
			Log.e("DatagramSocketClientReceiverWorker - Exception",
					ex.getMessage());
		}
	}

}
