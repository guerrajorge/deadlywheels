package groupa.deadlywheels;

import java.io.IOException;
import java.nio.IntBuffer;
import java.util.Date;

import javax.microedition.khronos.opengles.GL10;

import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Point;
import android.opengl.GLException;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.format.DateFormat;
import android.util.Log;
import android.view.Display;
import android.view.View;

import com.metaio.cloud.plugin.MetaioCloudPlugin;
import com.metaio.cloud.plugin.util.MetaioCloudUtils;
import com.metaio.sdk.ARViewActivity;
import com.metaio.sdk.MetaioDebug;
import com.metaio.sdk.jni.IGeometry;
import com.metaio.sdk.jni.IMetaioSDKCallback;
import com.metaio.tools.io.AssetsManager;


//public class Gametime extends ARViewActivity implements SensorEventListener
public class Gametime extends ARViewActivity
{
	private IGeometry modelCancunIT;
	private MetaioSDKCallbackHandler mCallbackHandler;
	AssetsExtracter mTask;
	
	//private SensorManager senSensorManager;
	//private Sensor senAccelerometer;
	
	
	//private long lastUpdate = 0;
	//private float last_x, last_y, last_z;
	//private static final int SHAKE_THRESHOLD = 200;

	/**
	 * This task extracts all the assets to an external or internal location
	 * to make them accessible to Metaio SDK
	 */
	private class AssetsExtracter extends AsyncTask<Integer, Integer, Boolean>
	{
		@Override
		protected Boolean doInBackground(Integer... params) 
		{
			try 
			{
				// Extract all assets and overwrite existing files if debug build
				AssetsManager.extractAllAssets(getApplicationContext(), BuildConfig.DEBUG);
			} 
			catch (IOException e) 
			{
				MetaioDebug.printStackTrace(Log.ERROR, e);
				return false;
			}

			return true;
		}
		
	}

	@Override
	public void onCreate(Bundle savedInstanceState) 
	{
		
		/*
		senSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
	    senAccelerometer = senSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
	    senSensorManager.registerListener(this, senAccelerometer , SensorManager.SENSOR_DELAY_NORMAL);
	    */
	    		
	    		
		//getting rib off the status bar
        //requestWindowFeature(Window.FEATURE_NO_TITLE);
        //this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
        
		//MetaioDebug.log(Log.ERROR, "executing assets extractor");
		//extract all the assets
		mTask = new AssetsExtracter();
		mTask.execute(0);
				
		//MetaioDebug.log(Log.ERROR, "the application starts");
		super.onCreate(savedInstanceState);
		modelCancunIT = null;
		mCallbackHandler = new MetaioSDKCallbackHandler();
		
		Display mdisp = getWindowManager().getDefaultDisplay();
		Point mdispSize = new Point();
		mdisp.getSize(mdispSize);
		int maxX = mdispSize.x; 
		int maxY = mdispSize.y;
		
		Bitmap bitmaps_received = createBitmapFromGLSurface(0,0,maxX, maxY, gl);
		
	}
	
	private Bitmap createBitmapFromGLSurface(int x, int y, int w, int h, GL10 gl) throws OutOfMemoryError {
	    int bitmapBuffer[] = new int[w * h];
	    int bitmapSource[] = new int[w * h];
	    IntBuffer intBuffer = IntBuffer.wrap(bitmapBuffer);
	    intBuffer.position(0);

	    try {
	        gl.glReadPixels(x, y, w, h, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, intBuffer);
	        int offset1, offset2;
	        for (int i = 0; i < h; i++) {
	            offset1 = i * w;
	            offset2 = (h - i - 1) * w;
	            for (int j = 0; j < w; j++) {
	                int texturePixel = bitmapBuffer[offset1 + j];
	                int blue = (texturePixel >> 16) & 0xff;
	                int red = (texturePixel << 16) & 0x00ff0000;
	                int pixel = (texturePixel & 0xff00ff00) | red | blue;
	                bitmapSource[offset2 + j] = pixel;
	            }
	        }
	    } catch (GLException e) {
	        return null;
	    }

	    return Bitmap.createBitmap(bitmapSource, w, h, Bitmap.Config.ARGB_8888);
	}

	@Override
	protected void onDestroy() 
	{
		super.onDestroy();
		mCallbackHandler.delete();
		mCallbackHandler = null;
	}
	
	@Override
	protected int getGUILayout() 
	{
		return R.layout.activity_gametime; 
	}
	
	@Override
	protected void loadContents() 
	{
		try
		{
			// Load desired tracking data for planar marker tracking
			final String trackingConfigFile;
			trackingConfigFile = AssetsManager.getAssetPath(getApplicationContext(), "dotnet/TrackingData_MarkerlessFast.xml");
			
			//MetaioDebug.log(Log.ERROR, "data to load: " + trackingConfigFile);
			final boolean result = metaioSDK.setTrackingConfiguration(trackingConfigFile);
			
			MetaioDebug.log(Log.ERROR, "data loaded: " + result);
			
			//cargando el modelo de cancunIT
			final String cancunITModel = AssetsManager.getAssetPath(getApplicationContext(), "dotnet/fence.mfbx");
			modelCancunIT = metaioSDK.createGeometry(cancunITModel);
			modelCancunIT.setScale(150.f);
		
			//start displaying the model
			modelCancunIT.setVisible(true);		
			mCallbackHandler.onTrackingEvent(metaioSDK.getTrackingValues());

		}
		catch (Exception e)
		{
			e.printStackTrace();
			MetaioDebug.log(Log.ERROR, "FAILED: ");
		}
	}
	
	@Override
	protected void onGeometryTouched(IGeometry geometry) 
	{
	}

	@Override
	protected IMetaioSDKCallback getMetaioSDKCallbackHandler() 
	{
		return mCallbackHandler;
	}
	
	final private class MetaioSDKCallbackHandler extends IMetaioSDKCallback 
	{
		@Override
		public void onSDKReady() 
		{
			// show GUI after SDK is ready
			runOnUiThread(new Runnable() 
			{
				@Override
				public void run() 
				{
					mGUIView.setVisibility(View.VISIBLE);
				}
			});
		}
	}
	
	/*
	protected void onPause() {
	    super.onPause();
	    senSensorManager.unregisterListener(this);
	}
	
	protected void onResume() {
	    super.onResume();
	    senSensorManager.registerListener(this, senAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);
	}

	@Override
	public void onAccuracyChanged(Sensor arg0, int arg1) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onSensorChanged(SensorEvent sensorEvent) {
		// TODO Auto-generated method stub
		Sensor mySensor = sensorEvent.sensor;
		 
	    if (mySensor.getType() == Sensor.TYPE_ACCELEROMETER) {
	        float x = sensorEvent.values[0];
	        float y = sensorEvent.values[1];
	        float z = sensorEvent.values[2];
	 
	        long curTime = System.currentTimeMillis();
	 
	        if ((curTime - lastUpdate) > 100) {
	            lastUpdate = curTime;
	 
	            System.out.println("the x value is: " + x);
	            System.out.println("the y value is: " + y);
	            System.out.println("the z value is: " + z);
	            	
	 
	            last_x = x;
	            last_y = y;
	            last_z = z;
	        }
	    }
		
	}
	*/
}

