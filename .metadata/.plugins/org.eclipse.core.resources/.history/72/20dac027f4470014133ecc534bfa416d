package groupa.deadlywheels;

import java.io.IOException;

import android.annotation.SuppressLint;
import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;

import com.metaio.sdk.ARViewActivity;
import com.metaio.sdk.MetaioDebug;
import com.metaio.sdk.jni.IGeometry;
import com.metaio.sdk.jni.IMetaioSDKCallback;
import com.metaio.tools.io.AssetsManager;


public class Gametime extends ARViewActivity 
{
	private SensorManager mSensorManager;
	private IGeometry modelCancunIT;
	private MetaioSDKCallbackHandler mCallbackHandler;
	AssetsExtracter mTask;
	public static final float EPSILON = 0.000000001f;
	
	
	// Create a constant to convert nanoseconds to seconds.
	private static final float NS2S = 1.0f / 1000000000.0f;
	private final float[] deltaRotationVector = new float[4];
	private float timestamp;

	/**
	 * This task extracts all the assets to an external or internal location
	 * to make them accessible to Metaio SDK
	 */
	private class AssetsExtracter extends AsyncTask<Integer, Integer, Boolean>
	{
		@Override
		protected Boolean doInBackground(Integer... params) 
		{
			try 
			{
				// Extract all assets and overwrite existing files if debug build
				AssetsManager.extractAllAssets(getApplicationContext(), BuildConfig.DEBUG);
			} 
			catch (IOException e) 
			{
				MetaioDebug.printStackTrace(Log.ERROR, e);
				return false;
			}

			return true;
		}
		
	}

	@Override
	public void onCreate(Bundle savedInstanceState) 
	{
		//getting rib off the status bar
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
        
		//MetaioDebug.log(Log.ERROR, "executing assets extractor");
		//extract all the assets
		mTask = new AssetsExtracter();
		mTask.execute(0);
				
		//MetaioDebug.log(Log.ERROR, "the application starts");
		super.onCreate(savedInstanceState);
		modelCancunIT = null;
		mCallbackHandler = new MetaioSDKCallbackHandler();
		
		mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
		mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
		
	}

	@Override
	protected void onDestroy() 
	{
		super.onDestroy();
		mCallbackHandler.delete();
		mCallbackHandler = null;
	}
	
	@Override
	protected int getGUILayout() 
	{
		return R.layout.activity_gametime; 
	}
	
	@Override
	protected void loadContents() 
	{
		try
		{
			// Load desired tracking data for planar marker tracking
			final String trackingConfigFile;
			trackingConfigFile = AssetsManager.getAssetPath(getApplicationContext(), "dotnet/TrackingData_MarkerlessFast.xml");
			
			//MetaioDebug.log(Log.ERROR, "data to load: " + trackingConfigFile);
			final boolean result = metaioSDK.setTrackingConfiguration(trackingConfigFile);
			
			MetaioDebug.log(Log.ERROR, "data loaded: " + result);
			
			//cargando el modelo de cancunIT
			final String cancunITModel = AssetsManager.getAssetPath(getApplicationContext(), "dotnet/fence.mfbx");
			modelCancunIT = metaioSDK.createGeometry(cancunITModel);
			modelCancunIT.setScale(150.f);
		
			//start displaying the model
			modelCancunIT.setVisible(true);		
			mCallbackHandler.onTrackingEvent(metaioSDK.getTrackingValues());

		}
		catch (Exception e)
		{
			e.printStackTrace();
			MetaioDebug.log(Log.ERROR, "FAILED: ");
		}
	}
	
	@Override
	protected void onGeometryTouched(IGeometry geometry) 
	{
	}

	@Override
	protected IMetaioSDKCallback getMetaioSDKCallbackHandler() 
	{
		return mCallbackHandler;
	}
	
	final private class MetaioSDKCallbackHandler extends IMetaioSDKCallback 
	{
		@Override
		public void onSDKReady() 
		{
			// show GUI after SDK is ready
			runOnUiThread(new Runnable() 
			{
				@Override
				public void run() 
				{
					mGUIView.setVisibility(View.VISIBLE);
				}
			});
		}
	}
	
	@SuppressLint("NewApi") public void onSensorChanged(SensorEvent event) {
		  // This timestep's delta rotation to be multiplied by the current rotation
		  // after computing it from the gyro sample data.
		  if (timestamp != 0) {
		    final float dT = (event.timestamp - timestamp) * NS2S;
		    // Axis of the rotation sample, not normalized yet.
		    float axisX = event.values[0];
		    float axisY = event.values[1];
		    float axisZ = event.values[2];

		    // Calculate the angular speed of the sample
		    float omegaMagnitude = (float)Math.sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);

		    // Normalize the rotation vector if it's big enough to get the axis
		    // (that is, EPSILON should represent your maximum allowable margin of error)
		    if (omegaMagnitude > EPSILON) {
		      axisX /= omegaMagnitude;
		      axisY /= omegaMagnitude;
		      axisZ /= omegaMagnitude;
		    }

		    // Integrate around this axis with the angular speed by the timestep
		    // in order to get a delta rotation from this sample over the timestep
		    // We will convert this axis-angle representation of the delta rotation
		    // into a quaternion before turning it into the rotation matrix.
		    float thetaOverTwo = omegaMagnitude * dT / 2.0f;
		    float sinThetaOverTwo = (float)Math.sin(thetaOverTwo);
		    float cosThetaOverTwo = (float)Math.cos(thetaOverTwo);
		    deltaRotationVector[0] = sinThetaOverTwo * axisX;
		    deltaRotationVector[1] = sinThetaOverTwo * axisY;
		    deltaRotationVector[2] = sinThetaOverTwo * axisZ;
		    deltaRotationVector[3] = cosThetaOverTwo;
		  }
		  timestamp = event.timestamp;
		  float[] deltaRotationMatrix = new float[9];
		  SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);
		    // User code should concatenate the delta rotation we computed with the current rotation
		    // in order to get the updated rotation.
		    // rotationCurrent = rotationCurrent * deltaRotationMatrix;
	}
}

